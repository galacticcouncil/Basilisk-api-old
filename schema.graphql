# TODO: look into using scalars (type alias)

interface Pool {
    id: ID!
    assetAId: BigInt
    assetBId: BigInt
    assetABalance: BigInt!
    assetBBalance: BigInt!
}

type LBPPool implements Pool @entity {
    "PoolId"
    id: ID!
    assetAId: BigInt!
    assetBId: BigInt!
    assetABalance: BigInt!
    assetBBalance: BigInt!
    saleEndAtRelayChainBlockHeight: Int
    historicalBalances: [HistoricalBalanceLBP!]! @derivedFrom(field: "pool")
}

type XYKPool implements Pool @entity {
    "PoolId"
    id: ID!
    assetAId: BigInt!
    assetBId: BigInt!
    assetABalance: BigInt!
    assetBBalance: BigInt!
    historicalBalances: [HistoricalBalanceXYK!]! @derivedFrom(field: "pool")
}

type BlockHeightPairing @entity {
    "paraChainBlockHash"
    id: ID!
    createdAt: DateTime!
    paraChainBlockHeight: BigInt!
    relayChainBlockHeight: BigInt!
}

# TODO generalize LBPPool reference to Pool; consider using union for XYKPool | LBPPool
type HistoricalBalanceLBP @entity {
    "PoolId-paraChainBlockHeight"
    id: ID!
    assetABalance: BigInt!
    assetBBalance: BigInt!
    createdAt: DateTime!
    pool: LBPPool!
    blockHeight: BlockHeightPairing!
}

type HistoricalBalanceXYK @entity {
    "PoolId-paraChainBlockHeight"
    id: ID!
    assetABalance: BigInt!
    assetBBalance: BigInt!
    createdAt: DateTime!
    pool: XYKPool!
    blockHeight: BlockHeightPairing!
}

type Chronicle @entity {
    id: ID!
    # TODO: use stateSubscription.lastCompletedBlock instead
    lastProcessedBlock: BigInt!
}

### UserActionLog 

type SellActionDetail {
    poolId: String!
    assetIn: BigInt!
    assetOut: BigInt!
    assetInAmount: BigInt!
    assetOutAmount: BigInt!
    sellPrice: BigInt!
    feeAsset: BigInt!
    feeAmount: BigInt!
}

type BuyActionDetail {
    poolId: String!
    assetOut: BigInt!
    assetIn: BigInt!
    assetOutAmount: BigInt!
    assetInAmount: BigInt!
    buyPrice: BigInt!
    feeAsset: BigInt!
    feeAmount: BigInt!
}

type LiquidityAddedActionDetail {
    poolId: String!
    assetA: BigInt!
    assetB: BigInt!
    assetAAmount: BigInt!
    assetBAmount: BigInt!
}

type LiquidityRemovedActionDetail {
    poolId: String!
    assetA: BigInt!
    assetB: BigInt!
    assetAAmount: BigInt!
    assetBAmount: BigInt!
}

union UserActionDetail = SellActionDetail | BuyActionDetail | LiquidityAddedActionDetail | LiquidityRemovedActionDetail

enum UserActionType {
    Buy, # LBP & XYK
    Sell, # LBP & XYK
    AddLiquidity, # XYK
    RemoveLiquidity, # XYK
    SetFeeAsset,
    Transfer,
    XCM, # cross chain transfer
}

# Processor will always use isFinalized
enum Status {
    isBroadcast
    isInBlock
    isFinalized 
}

type UserAction @entity {
    # transactionHash
    id: ID!
    status: Status!
    account: String!
    action: UserActionType!
    detail: UserActionDetail
    paraChainBlockHeight: BigInt
}


### Testing

type TestBlock @entity {
  blockHeight: BigInt!,
  createdAt: DateTime!,
  poolId: Int!
}
