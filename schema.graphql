# TODO: look into using scalars (type alias)

interface Pool {
    id: ID!
    assetAId: BigInt
    assetBId: BigInt
    assetABalance: BigInt!
    assetBBalance: BigInt!
}

type LBPPool implements Pool @entity {
    "PoolId"
    id: ID!
    assetAId: BigInt
    assetBId: BigInt
    assetABalance: BigInt!
    assetBBalance: BigInt!
    saleEndAtRelayChainBlockHeight: BigInt
    saleEnded: Boolean
    historicalBalances: [HistoricalBalance!]! @derivedFrom(field: "pool")
}

type HistoricalBalance @entity {
  "paraChainBlockHeight"
  id: ID!
  pool: LBPPool!
  assetABalance: BigInt!
  assetBBalance: BigInt!
  relayChainBlockHeight: BigInt!
}

type Chronicle @entity {
  id: ID!
  # TODO: use stateSubscription.lastCompletedBlock instead
  lastProcessedBlock: BigInt!
}